metavar tname, x, y, z, f, g, n ::=
  {{ com variables }}
  {{ lex alphanum }}

metavar mname, M ::=
  {{ com module names }}
  {{ lex alphanum }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Core language

grammar


tm, a , b , A , B , u , v :: '' ::= {{ com terms and types }}

  | Type        ::    :: Type {{ com sort }}

  | x           ::    :: Var {{ com variable }}

  | \ x . a            ::  :: Lam 
    {{ tex \lambda [[x]]. [[a]] }}
    {{ com function }}    

  | a b                ::   :: App 
    {{ tex [[a]] \; [[b]] }}
    {{ com function application }}

  | ( x : A ) -> B    ::    :: Pi   
    {{ tex ([[x]]\!:\![[A]]) [[->]] [[B]] }}
    {{ com dependent function type }}

  %% Practicalities
  | a { b / x } :: S  :: SubstOp 
    {{ com substitution }}

  | A -> B      :: M  :: Arrow
    {{ com syntactic sugar for function types }}

  | ( a : A )   ::    :: Ann 
    {{ com type annotation }}

  | ( a )       :: S  :: Paren 
    {{ com parenthesis }}

  | TRUSTME         ::   :: TrustMe   {{ com A term that has any type }}
  | PRINTME         ::   :: PrintMe   {{ com Print the current context }}

  | let x = a in b  ::   :: Let {{ com Name an expression }}


  %% Unit

  | Unit          ::   :: TyUnit  {{ com unit type }}
  | ()            ::   :: LitUnit  {{ com unit term }}

  %% Booleans

  | Bool                  ::   :: TyBool {{ com boolean type }}
  | True                  ::   :: LitTrue {{ com boolean value true }}
  | False                 ::   :: LitFalse {{ com boolean value false }}
  | if a then b1 else b2  ::   :: If {{ com conditional }}

  %% Sigma types

  | { x : A | B } ::   :: Sigma
    {{ tex \{ [[x]]\!:\![[A]]\ |\ [[B]] \} }}
    {{ com $\Sigma$-type (i.e. dependent products/dependent sums) }}

  | ( a , b )     ::   :: Prod {{ com product }}

  | let ( x , y ) = a in b ::  :: LetPair {{ com elimination form for pairs }}

  %% Equality
  | a = b         ::   :: TyEq   {{ com equality type }}
  | refl          ::   :: Refl   {{ com reflexivity proof }}
  | subst a by b  ::   :: Subst  {{ com equality type elimination }}
  | contra a      ::   :: Contra {{ com false elimination }}


substitutions
  single a x     :: subst_tm

freevars
  a x   :: fv_tm

parsing 
Ann right Arrow
Arrow right Arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

context, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com contexts }}

   |                 ::    :: Nil  

   | G , x : A       ::    :: Cons   {{ tex [[G]], [[x]]\! :\![[A]] }}

   | x : A           ::    :: Single {{ tex [[x]]\! :\![[A]] }}

terminals :: 'terminals_' ::=
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}
  | -->               ::   :: step          {{ tex \longrightarrow }}
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ==                ::   :: definitional  {{ tex \equiv }}
  | all               ::   :: forall        {{ tex \forall }}
  | elem              ::   :: elem          {{ tex \in }}
  | notin             ::   :: notin         {{ tex \not\in }}
  | <=                ::   :: check         {{ tex \Leftarrow }}
  | =>                ::   :: infer         {{ tex \Rightarrow }}
  | =>*               ::   :: minfer        {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow         {{ tex \to }}
  | /\                ::   :: ilam          {{ tex \mathrm{\Lambda} }}   
  | []                ::   :: box        {{ tex \Box }}
  | |-                ::   :: entails    {{ tex \vdash }}
  | |=                ::   :: hs_entails {{ tex \vDash }}
  | /=                ::   :: neq        {{ tex \neq }}
  | |>                ::   :: cast       {{ tex \triangleright }}
  | ok                ::   :: ok         {{ tex \ \mathsf{ok} }}
  | _                 ::   :: blank      {{ tex \_ }}
  | ~>                ::   :: produce    {{ tex \leadsto }}
  | ~>*               ::   :: multistep  {{ tex \leadsto^{\ast} }}
  | empty             ::   :: empty      {{ tex \varnothing }}
  | hole              ::   :: hole       {{ tex \circ }}
  | fv                ::   :: fv         {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom        {{ tex \mathsf{dom} }}
  | ~                 ::   :: twiddle    {{ tex \sim }}
  | ~~                ::   :: compatible {{ tex \asymp }}
  | '|'               ::   :: bar        {{ tex | }}
  | o                 ::   :: bullet     {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | ==>               ::   :: impl       {{ tex \implies }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | x : A elem G             ::   :: inG

defns 
Jwhnf :: '' ::= 

% For closed terms, these rules correspond to a big-step evaluation relation.
% This relation is semi-decidable, so we can express it as a Haskell function
% that may diverge. 

defn
whnf a = v ::    :: whnf :: 'whnf_' 
{{ com evaluate a to v }}
by

whnf a = (\x.a)
whnf (a { b / x}) = v
---------------------- :: Lam
whnf a b = v


whnf (b { a / x}) = v
------------------------------- :: Let
whnf (let x = a in b) = v

whnf a = True
whnf b1 = v
--------------------------- :: IfTrue
whnf if a then b1 else b2 = v

whnf a = False
whnf b2 = v
------------------------------- :: IfFalse
whnf if a then b1 else b2 = v


whnf a = (a1, a2) 
whnf b { a1 / x} {a2 /y} = v
------------------------------- :: Prod
whnf let (x,y) = a in b = v

%% congruence rules 
%% for open terms (i.e terms with free variables), the result is not a value
%% but a term in "head normal form" i.e.
%%    v ::= value (i.e.  Type, \x.a, (x:A) -> B, {x:A | B},  True/False, (a,b) )
%%          x 
%%          v b
%%          if v then b1 else b2
%%          let (x,y) = v in b

whnf a = v
---------------------- :: LamCong
whnf a b = v b

whnf a = v
---------------------------------------------------- :: IfCong
whnf if a then b1 else b2 = if v then b1 else b2

whnf a = v
------------------------------------------ :: ProdCong
whnf let (x,y) = a in b = let (x,y) = v in b

defns
JOp :: '' ::=

defn
a ~> b ::   :: step :: 's_'
{{ com single-step operational semantics, i. e. head reduction }}
by



----------------------------------  :: AppAbs
(\x.a) b ~> a { b / x}


--------------------------------- :: Let
let x = a in b ~> b { a / x } 


---------------------------------- :: IfTrue
if True then b1 else b2 ~> b1


---------------------------------- :: IfFalse
if False then b1 else b2 ~> b1


-------------------------------------------------- :: LetPairProd
let (x,y) = (a1,a2) in b ~> b { a1 /x } {a2 /y }

a ~> a'
------------------------  :: App
a b ~> a' b

a ~> a'
--------------------------------- :: If
if a then b1 else b2 ~> if a' then b1 else b2

a ~> a'
-------------------------------------------------- :: LetPair
let (x,y) = a in b ~> let (x,y) = a' in b


defn
a ~>* b ::  :: reduction :: ''
{{ com multi-step head reduction }}
by

------------------- :: Equal
a ~>* a

a ~> b
b ~>* a'
------------------- :: Step
a ~>* a'


defns 
JEq :: '' ::=

defn
G |- A = B ::  :: eq :: 'e_'
{{ com Definitional equality }}
by

-------------------------- :: beta
G |- (\x.a)b = a {b / x}

----------------------------- :: if_true
G |- if true then a else b = a

------------------------------- :: if_false
G |- if false then a else b = b

---------------------------------------------------------- :: letpairprod
G |- let (x,y) = (a1,a2) in b = b { a1 /x } {a2 / y} 

 ----------  :: refl
 G |- A = A
 
 G |- A = B
 -----------  :: sym
 G |- B = A
 
 G |- A = B    
 G |- B = C
 ------------------------- :: trans
 G |- A = C

 G |- A1 = A2       
 G,x:A1 |- B1 = B2
 ------------------------------------ :: pi
 G |- (x:A1) -> B1 = (x:A2) -> B2


 G,x:A1 |- b1 = b2
 ------------------- :: lam
 G |- \x.b1 = \x.b2


 G |- a1 = a2    
 G |- b1 = b2 
 -------------------------- :: app
 G |- a1 b1 = a2 b2


G |- a = a'
G |- b1 = b1'
G |- b2 = b2'
-------------- :: if
G |- if a then b1 else b2 = if a' then b1' else b2'

G |- A1 = A2       
G,x:A1 |- B1 = B2
------------------------------------ :: sigma
G |- { x:A1 | B1 } = { x:A2 |  B2} 


G |- b1 = b1'
G |- b2 = b2'
-------------- :: prod
G |- (b1, b2) = (b1', b2')

G |- a = a'
G |- b = b'
----------------------------------------------- :: letpair
G |- let (x,y) = a in b = let (x,y) = a' in b'

G, x : A |- b : B   
G |- a1 = a2     
---------------------------------- :: subst
G |- b {a1 / x} = b {a2 / x}

-------------------------------- :: if_eta
G |- if a then b else b = b


defns
JTyping :: '' ::= 

defn 

G |- a : A   ::   :: typing :: 't_'
{{ com Typing }}
by

x : A elem G
----------- :: var 
G |- x : A


G, x:A |- a : B
------------------------  ::  slambda
G |- \x.a : (x:A) -> B


G, x:A |- a : B
G |- a : Type
------------------------  ::  lambda
G |- \x.a : (x:A) -> B


G |- A : Type     
G, x:A |- B : Type
-------------------------------------- :: pi
G |- (x:A) -> B : Type

----------------  :: type
G |- Type : Type


G |- a : (x:A) -> B 
G |- b : A
--------------------------- ::  app
G |- a b : B { b / x }


%% booleans

---------------- :: bool
G |- Bool : Type

---------------- :: true
G |- True : Bool

---------------- :: false
G |- False : Bool
     
G |- a : Bool 
G |- b1 : A
G |- b2 : A
---------------------------- :: if_weak
 |- if a then b1 else b2 : A

G |- a : Bool 
G |- b1 : A { true/x }
G |- b2 : A { false/x }
-------------------------------- :: if_full
G |- if a then b1 else b2 : A{a/x}

G |- x : Bool 
G |- b1 : A { true / x }
G |- b2 : A { false / x }
---------------------------- :: if
G |- if x then b1 else b2 : A 


%% sigma types

G |- A : Type     
G, x:A |- B : Type
------------------------------------- :: sigma
G |- { x : A | B } : Type

G |- a : A      
G |- b : B { a / x }
------------------------------------ :: pair
G |- (a,b) : { x : A | B }


G |- a : { x : A1 | A2 }
G, x:A1, y:A2 |- b : B
G |- B : Type
------------------------------ :: letpair_weak
G |- let (x,y) = a in b : B

%% equality

G |- a : A    
G |- A = B
------------ :: conv
G |- a : B


G |- a = b
------------------- :: refl
G |- refl : a = b

------------------- :: refl_s
G |- refl : a = a

G |- a : A    
G |- b : A
------------------------- :: eq
G |- a = b : Type

G |- a : A { a1 / x }  
G |- b : a1 = a2
--------------------------------- :: subst
G |- subst a by b : A { a2 / x }




defns
Jalgeq :: '' ::= 

defn 
G |- A <=> A' ::    :: equate :: 'q_'
{{ com algorithmic equality }}
by





defns
JBidirectional :: '' ::= 

defn 
G |- a => A ::    :: inferType :: 'i_'
{{ com type synthesis (algorithmic) }}
by

x : A elem G
----------- :: var 
G |- x => A


G |- a <= A 
------------------ :: annot
G |- (a : A) => A

G |- a => (x:A) -> B 
G |- b <= A
---------------------------  :: app_simple
G |- a b => B { b / x }	  


G |- A <= Type     
G, x:A |- B <= Type
-------------------------------------- :: pi
G |- (x:A) -> B => Type

------------------- :: type
G |- Type => Type

G |- a <= A
------------------ :: ann
G |- (a : A) => A

%% booleans

---------------- :: bool
G |- Bool => Type

---------------- :: true
G |- True => Bool

---------------- :: false
G |- False => Bool

%% app with arrow reduction

G |- a => A 
whnf A = (x:A1) -> B 
G |- b <= A1
---------------------------  :: app
G |- a b => B { b / x }	  

     
G |- a => Bool 
G |- b1 => B1
G |- b2 => B2
----------------------------------------------- :: if_alt
G |- if a then b1 else b2 => if a then B1 else B2


defn 
G |- a <= B ::    :: checkType :: 'c_'
{{ com type checking (algorithmic) }}
by

G, x:A |- a <= B       
G |- A <= Type
--------------------------- ::  lambda
G |- \x.a <= (x:A) -> B

G |- a => A
------------- :: infer_simple 
G |- a <= A 

G |- a => A    
G |- A = B
-------------------------- :: infer
G |- a <= B


%% booleans

G |- a <= Bool 
G |- b1 <= A
G |- b2 <= A
---------------------------- :: if_weak
 |- if a then b1 else b2 <= A


 G |- x => Bool 
 G |- b1 <= A { true / x }
 G |- b2 <= A { false / x }
 ------------------------------ :: if
 G |- if x then b1 else b2 <= A


%% sigma types

G |- A <= Type     
G, x:A |- B <= Type
------------------------------------- :: sigma
G |- { x : A | B } <= Type

G |- a <= A      
G |- b <= B { a / x }
------------------------------------ :: pair
G |- (a,b) <= { x : A | B }

G |- a => { x : A1 | A2 }
G, x:A1, y:A2 |- b <= B
G |- B <= Type
------------------------------ :: letpair_weak
G |- let (x,y) = a in b <= B

G |- z => { x : A1 | A2 }
G, x:A1, y:B2 |- b <= B { (x,y) / z }
G |- B <= Type
-------------------------------------- :: letpair
G |- let (x,y) = z in b <= B
