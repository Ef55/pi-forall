module Lec4 where

import Nat

-- can mark some arguments as irrelevant

id : [x:Type] -> (y : x) -> x
id = \[x] y. (y : x)

t0 = id [Bool] True

t1 = id [Bool] (id [Bool] True)

{-  This shouldn't work 
id' : [x:Type] -> [y:x] -> x
id' = \[x][y]. y
-}

-----------------------------------------------------
--  Irrelevant arguments ignored during type equality

irrelevance : (p : [i : Nat] -> Nat) -> p [1] = p [2]
irrelevance = \p . Refl

-----------------------------------------------------
-- Propositional equality is relevant
-- Cannot ignore/erase proofs that are used for casts. 
-- Need a terminating system to even think about this possibility.

proprel : [a : Type] -> (pf : a = Bool) -> (x : a) -> Bool
proprel = \[a] pf x . 
  subst x by pf 

-----------------------------------------------------
-- The trade off for Sigma types in the context of irrelevance. 
-- If the first argument is irrelevant, we only have weak elimination
-- available.

-- Existential type
data Exists (B: Type -> Type) : Type where
  Pack of [x:Type] (B x)

counter : (Nat -> Nat) * (Nat -> Nat) * (Nat -> Nat)
counter = (\x . 0, ( \x. Succ x , \x . x))

-- This doesn't work
{-
ty : [B: Type -> Type] -> Exists B -> Type 
ty = \ [B]  x . case x of 
  Pack [x] y -> x

open : [B:Type -> Type] -> (x : Exists B) -> B (case x of Pack [x] y -> x)
open = \ [B]  x . case x of 
  Pack [z] y -> y
-}

-----------------------------------------------------------
-- Example of an abstract type with an irrelevant first component
-- must use case to destruct

Abs : Type
Abs = Exists (\t. (Nat -> t) * (t -> t) * (t -> Nat))

abs : Abs
abs = Pack [Nat] counter

example : Abs -> Nat
example = \ a . 
  case a of 
    Pack [t] tuple -> 
      let (constr, rest) = tuple in 
      let (incr, toNat) = rest in 
      toNat (incr (constr 0))

-----------------------------------------------
-- Example of an abstract type with an "relevant" first component
-- can define strong elimnators 


Abs2 : Type
Abs2 = { t : Type | (Nat -> t) * (t -> t) * (t -> Nat) }

abs2 : Abs2
abs2 = ( Nat , counter )

ty : (a : Abs2) -> Type
ty = \a. let (x,y) = a in x

constr : (a : Abs2) -> Nat -> (ty a)
constr = \a. let (x,y) = a in 
  let (c, rest) = y in 
  c

incr : (a : Abs2) -> ty a -> ty a 
incr = \a. let (x,y) = a in 
  let (c, r) = y in 
  let (i, t) = r in 
  i

toNat : (a : Abs2) -> ty a -> Nat 
toNat = \a. let (x,y) = a in 
  let (c, r) = y in 
  let (i, t) = r in 
  t

example2 : Abs2 -> Nat
example2 = \ a .   
  toNat a (incr a (constr a 0))

-- This doesn't type check. The type system prevents us from 
-- confusing two different abstract types
-- 
example2 : Abs2 -> Abs2 -> Nat
example2 = \ a b .   
  toNat a (incr b (constr a 0))
